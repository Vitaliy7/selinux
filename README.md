# selinux
## Домашнее задание по теме _SELinux - когда все запрещено_

>1.Запустить nginx на нестандартном порту 3-мя разными способами:  
>> * переключатели setsebool;  
>> * добавление нестандартного порта в имеющийся тип;  
>> * формирование и установка модуля SELinux.  
>> * К сдаче:
README с описанием каждого решения (скриншоты и демонстрация приветствуются).  


>2.Обеспечить работоспособность приложения при включенном selinux.  
>> * развернуть приложенный стенд https://github.com/mbfx/otus-linux-adm/tree/master/selinux_dns_problems;
>> * выяснить причину неработоспособности механизма обновления зоны (см. README);
>> * предложить решение (или решения) для данной проблемы;
>> * выбрать одно из решений для реализации, предварительно обосновав выбор;
>> * реализовать выбранное решение и продемонстрировать его работоспособность.
>> * К сдаче:  
README с анализом причины неработоспособности, возможными способами решения и обоснованием выбора одного из них;  
исправленный стенд или демонстрация работоспособной системы скриншотами и описанием.

## Решение ДЗ

#### 1. Запустить nginx на нестандартном порту 3-мя разными способами:  

Создаем _Vagrantfile_ , как указано в инструкции к домашнему заданию и запускаем его `vagrant up`. Попытка запустить завершается с ошибкой `nginx`, поскольку `selinux` блокирует работу на нестандартном порту. Подключаемся `vagrant ssh`, проверяем состояние файерволла , `nginx` и режим работы `selinux`

![](https://github.com/Vitaliy7/selinux/blob/main/selinux.png?raw=true)

##### a) Разрешим в `selinux` работу `nginx` на порту TCP 4881 c помощью переключателей `setsebool`  

Находим в логах (/var/log/audit/audit.log) при помощи утилиты `audit2why` информацию о блокировании порта. Вывод команды подсказывает, что нам надо поменять параметр `nis_enabled`, что мы и сделаем. Перезапускаем `nginx` и смотрим его статус:

![](https://github.com/Vitaliy7/selinux/blob/main/selinux1.png?raw=true)

На хосте открываем браузер и переходим по адресу _127.0.0.1:4881_. Всё работает:

![](https://github.com/Vitaliy7/selinux/blob/main/selinux2.png?raw=true)

Для продолжения выполнения домашнего задания вернём запрет работы nginx на порту 4881 обратно. _`setsebool -P nis_enabled off`_

##### b) Разрешаем в `selinux` работу `nginx` на порту TCP 4881 c помощью добавления нестандартного порта в имеющийся тип:

Для начала найдем имеющийся тип `http` трафика. Затем добавим порт в тип `http_port_t` при помощи команды `semanage port -a -t http_port_t -p tcp 4881`. Далее, по аналогии с предыдущей частью, перезапускаем `nginx`, смотрим его статус и открываем дефолтную страницу из браузера на хосте.

![](https://github.com/Vitaliy7/selinux/blob/main/selinux3.png?raw=true)

Удаляем этот порт из имеющегося типа с помощью команды `semanage port -d -t http_port_t -p tcp 4881`

##### c) Разрешим в `selinux` работу `nginx` на порту TCP 4881 c помощью формирования и установки модуля `selinux` :

Воспользуемся утилитой `audit2allow` для того, чтобы на основе логов `Sselinux` сделать модуль, разрешающий работу `nginx` на нестандартном порту. Утилита `audit2allow` сформировала модуль, и сообщила нам команду, с помощью которой можно применить данный модуль: `semodule -i nginx.pp`. После добавления модуля и перезапуска `nginx` запустился без ошибок. 

![](https://github.com/Vitaliy7/selinux/blob/main/selinux4.png?raw=true)

При использовании модуля изменения сохраняются после перезагрузки.




#### 2. Обеспечить работоспособность приложения при включенном selinux.  

Скачиваем данные из репозитория `git clone https://github.com/mbfx/otus-linux-adm.git`

Запускаем наши виртуальные машины, подключаемся к клиентской машине и пробуем внести изменения в зону.
Изменить не получилось( Смотрим логи _selinux_ с помощью утилиты `audit2why`, чтобы понять источник проблемы. На клиенте ошибок нет:

![](https://github.com/Vitaliy7/selinux/blob/main/client1.png?raw=true)

Теперь, не отключаясь от клиента, подключаемся к серверу и проверяем логи selinux при помощи той же `audit2why`
Из логов становится ясно, что ошибка в контексте безопасности, т.к. у нас вместо типа `named_t` используется `etc_t`, затем смотрим каталог `/etc/named`
Проблема заключается в том, что конфигурационные файлы лежат в другом каталоге. Смотрим, в каком каталоги должны лежать файлы, чтобы на них распространялись правильные политики selinux:

![](https://github.com/Vitaliy7/selinux/blob/main/server1.png?raw=true)

Изменим тип контекста безопасности для каталога `/etc/named` и проверяем его:

![](https://github.com/Vitaliy7/selinux/blob/main/server2.png?raw=true)

Опять заходим на клиента и пробуем снова внести изменения. Видим, что на этот раз получилось): 

![](https://github.com/Vitaliy7/selinux/blob/main/client2.png?raw=true)

Перезагружаем хосты и еще раз делаем запрос с помощью инструмента для опроса DNS-серверов `dig`:

сервер

![](https://github.com/Vitaliy7/selinux/blob/main/server3.png?raw=true)

клиент

![](https://github.com/Vitaliy7/selinux/blob/main/client3.png?raw=true)

Как видим, после перезагрузки настройки сохранились.
